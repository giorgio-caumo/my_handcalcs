import sympy as sp
from IPython.core.magic import register_cell_magic
from IPython.display import display, Latex
from sympy.parsing.sympy_parser import parse_expr

@register_cell_magic
def render(line, cell):
    # Read the decimal places argument
    args = line.strip().split()
    decimal_places = int(args[0]) if args and args[0].isdigit() else None

    lines = cell.strip().split('\n')
    rendered_lines = []
    global_namespace = globals()

    for line in lines:
        # Identify comment style and split
        if '#' in line:
            code, comment = line.split('#', 1)
            comment = comment.strip()
            code = code.strip()

            # Determine mode based on comment type
            if comment.startswith('*'):
                mode = 'input'
            elif comment.startswith('L'):
                mode = 'long'
            else:
                mode = 'standard'
                
            if '@' in comment:
                left_comment, right_comment = comment.split('@', 1)
            else:
                left_comment, right_comment = comment, ""
        else:
            code = line.strip()
            left_comment = ''
            right_comment = ''
            mode = 'standard'

        if '=' in code:
            # Split the code into variable and expression
            var, expr = code.split('=', 1)
            var = var.strip()
            expr = expr.strip()

            # Parse the expression using sympy
            parsed_expr = parse_expr(expr, local_dict=global_namespace)
            result = parsed_expr.evalf()  # Get numerical result using sympy's evalf()
            global_namespace[var] = result

            # Convert variable and expression to LaTeX
            var_latex = sp.latex(sp.symbols(var))  # Convert variable to LaTeX
            expr_latex = sp.latex(parsed_expr)  # Convert expression to LaTeX

            # Format the result
            if parsed_expr.is_number:
                # Apply decimal places if it's a number
                if decimal_places is not None:
                    result_latex = f"{result:.{decimal_places}f}"
                else:
                    result_latex = sp.latex(result)
            else:
                # If it's symbolic, use sympy's latex conversion
                result_latex = sp.latex(result)

            # Handle different modes based on the comment
            if mode == 'input':  # input mode: variable = expression
                rendered_line = f'\\text{{{left_comment}}} & {var_latex} & = {expr_latex} & & \\text{{{right_comment}}}\\\\'
            elif mode == 'long':  # long mode: variable = expression and then result on a new line
                rendered_line = f'\\text{{{left_comment}}} & {var_latex} & = {expr_latex} & & \\text{{{right_comment}}}\\\\  & & = {result_latex} & &  \\\\'
            else:  # standard mode: variable = expression = result
                rendered_line = f'\\text{{{left_comment}}} & {var_latex} & = {expr_latex} & = {result_latex} & \\text{{{right_comment}}}\\\\'

            # if right_comment:
            #     rendered_line += f'\\text{{{right_comment.strip()}}}'
        else:
            # If no assignment, just process the comment and code as-is
            parsed_expr = parse_expr(code, local_dict=global_namespace)
            expr_latex = sp.latex(parsed_expr)  # Convert expression to LaTeX
            rendered_line = f'\\text{{{left_comment}}} & {expr_latex} \\\\'

        rendered_lines.append(rendered_line)

    # Create the LaTeX table with increased vertical spacing
    table_latex = '$\\begin{array}{lllll}\n' + '\n'.join(rendered_lines) + '\n\\end{array}$'
    table_latex = table_latex.replace('\\\\', '\\\\[2ex]')  # Increase vertical spacing
    display(Latex(table_latex))
